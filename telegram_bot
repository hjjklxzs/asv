#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging
import os
import json
import time
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes, ConversationHandler

# ØªÙƒÙˆÙŠÙ† Ø§Ù„ØªØ³Ø¬ÙŠÙ„
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª
TOKEN = "7289010404:AAHC6uBYg7UFFoQmv1Z3IF4UTONaXTr-9-4"

# Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„ÙˆØ­ÙŠØ¯
ADMIN_ID = 5309697442

# Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ù„Ùƒ
OWNER_USERNAME = "@uflooe"
OWNER_CHANNEL = "https://t.me/df_okl2"

# Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
MAIN_MENU, ADMIN_MENU, ADD_PRODUCT, PRODUCT_NAME, PRODUCT_DESCRIPTION, PRODUCT_PRICE, PRODUCT_FILE, BROWSE_PRODUCTS, PRODUCT_DETAILS, CONFIRM_PURCHASE, ADMIN_APPROVE, WAITING_PAYMENT = range(12)

# Ù…Ù„Ù ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
PRODUCTS_FILE = 'products.json'
ORDERS_FILE = 'orders.json'

# Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
def ensure_data_files():
    if not os.path.exists(PRODUCTS_FILE):
        with open(PRODUCTS_FILE, 'w', encoding='utf-8') as f:
            json.dump([], f, ensure_ascii=False)
    
    if not os.path.exists(ORDERS_FILE):
        with open(ORDERS_FILE, 'w', encoding='utf-8') as f:
            json.dump([], f, ensure_ascii=False)

# Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
def load_products():
    try:
        with open(PRODUCTS_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

# Ø­ÙØ¸ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
def save_products(products):
    with open(PRODUCTS_FILE, 'w', encoding='utf-8') as f:
        json.dump(products, f, ensure_ascii=False, indent=4)

# Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª
def load_orders():
    try:
        with open(ORDERS_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

# Ø­ÙØ¸ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
def save_orders(orders):
    with open(ORDERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(orders, f, ensure_ascii=False, indent=4)

# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø´Ø±Ù
def is_admin(user_id):
    return str(user_id) == str(ADMIN_ID)

# Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¨ÙˆØª
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    keyboard = [
        [KeyboardButton("ğŸ› ØªØµÙØ­ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª")],
        [KeyboardButton("ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ"), KeyboardButton("/start")]
    ]
    
    # Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ù…Ø´Ø±Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ø§Ù„Ù…Ø´Ø±Ù
    if is_admin(user.id):
        keyboard.append([KeyboardButton("ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù")])
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name} ÙÙŠ Ù…ØªØ¬Ø± {OWNER_USERNAME} Ø§Ù„Ø±Ù‚Ù…ÙŠ! ğŸ‰\n\n"
        f"ÙŠÙ…ÙƒÙ†Ùƒ ØªØµÙØ­ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© ÙˆØ§Ù„Ø´Ø±Ø§Ø¡ Ø¨ÙƒÙ„ Ø³Ù‡ÙˆÙ„Ø©.\n\n"
        f"Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ Ù…Ø¨Ø§Ø´Ø±Ø©: {OWNER_USERNAME}\n"
        f"Ù‚Ù†Ø§Ø© Ø§Ù„Ù…ØªØ¬Ø±: {OWNER_CHANNEL}",
        reply_markup=reply_markup
    )
    
    return MAIN_MENU

# Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù
async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    
    if not is_admin(user.id):
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    keyboard = [
        [KeyboardButton("â• Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯")],
        [KeyboardButton("ğŸ“Š Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª"), KeyboardButton("ğŸ—‘ Ø­Ø°Ù Ù…Ù†ØªØ¬")],
        [KeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ]
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù! ğŸ”\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø·Ù„Ø¨Ø§Øª Ù…Ù† Ù‡Ù†Ø§.",
        reply_markup=reply_markup
    )
    
    return ADMIN_MENU

# Ø¨Ø¯Ø¡ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯
async def add_product_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    
    if not is_admin(user.id):
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    await update.message.reply_text(
        "Ù„Ù†Ø¨Ø¯Ø£ Ø¨Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯! ğŸ†•\n\n"
        "Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬:"
    )
    
    return PRODUCT_NAME

# Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬
async def receive_product_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['product_name'] = update.message.text
    
    await update.message.reply_text(
        "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬! âœ…\n\n"
        "Ø§Ù„Ø¢Ù†ØŒ Ø£Ø±Ø³Ù„ ÙˆØµÙ Ø§Ù„Ù…Ù†ØªØ¬:"
    )
    
    return PRODUCT_DESCRIPTION

# Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ ÙˆØµÙ Ø§Ù„Ù…Ù†ØªØ¬
async def receive_product_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['product_description'] = update.message.text
    
    await update.message.reply_text(
        "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ÙˆØµÙ Ø§Ù„Ù…Ù†ØªØ¬! âœ…\n\n"
        "Ø§Ù„Ø¢Ù†ØŒ Ø£Ø±Ø³Ù„ Ø³Ø¹Ø± Ø§Ù„Ù…Ù†ØªØ¬ (Ø±Ù‚Ù… ÙÙ‚Ø·):"
    )
    
    return PRODUCT_PRICE

# Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø³Ø¹Ø± Ø§Ù„Ù…Ù†ØªØ¬
async def receive_product_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        price = float(update.message.text)
        context.user_data['product_price'] = price
        
        await update.message.reply_text(
            "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø³Ø¹Ø± Ø§Ù„Ù…Ù†ØªØ¬! âœ…\n\n"
            "Ø£Ø®ÙŠØ±Ø§Ù‹ØŒ Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ù„Ù (ØµÙˆØ±Ø©ØŒ ÙÙŠØ¯ÙŠÙˆØŒ Ù…Ù„ÙØŒ Ø¥Ù„Ø®) Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¨ÙŠØ¹Ù‡:"
        )
        
        return PRODUCT_FILE
    except ValueError:
        await update.message.reply_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø³Ø¹Ø± Ø±Ù‚Ù…Ø§Ù‹. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:"
        )
        
        return PRODUCT_PRICE

# Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù…Ù„Ù Ø§Ù„Ù…Ù†ØªØ¬
async def receive_product_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.message
    
    # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù ÙˆØ­ÙØ¸ Ù…Ø¹Ø±ÙÙ‡
    file_id = None
    file_type = None
    
    if message.photo:
        file_id = message.photo[-1].file_id
        file_type = "photo"
    elif message.document:
        file_id = message.document.file_id
        file_type = "document"
    elif message.video:
        file_id = message.video.file_id
        file_type = "video"
    elif message.audio:
        file_id = message.audio.file_id
        file_type = "audio"
    elif message.voice:
        file_id = message.voice.file_id
        file_type = "voice"
    elif message.text:
        file_id = message.text
        file_type = "text"
    
    if not file_id:
        await message.reply_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:"
        )
        return PRODUCT_FILE
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ù†ØªØ¬
    product_id = str(int(time.time()))
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    new_product = {
        "id": product_id,
        "name": context.user_data['product_name'],
        "description": context.user_data['product_description'],
        "price": context.user_data['product_price'],
        "file_id": file_id,
        "file_type": file_type,
        "added_by": update.effective_user.id,
        "added_at": int(time.time())
    }
    
    # Ø­ÙØ¸ Ø§Ù„Ù…Ù†ØªØ¬
    products = load_products()
    products.append(new_product)
    save_products(products)
    
    # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    context.user_data.clear()
    
    await message.reply_text(
        "ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬ Ø¨Ù†Ø¬Ø§Ø­! âœ…\n\n"
        f"Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬: {new_product['name']}\n"
        f"Ø§Ù„Ø³Ø¹Ø±: {new_product['price']}\n\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¢Ø®Ø± Ø£Ùˆ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù."
    )
    
    return ADMIN_MENU

# ØªØµÙØ­ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
async def browse_products(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    products = load_products()
    
    if not products:
        await update.message.reply_text(
            "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹. ğŸ˜”\n"
            "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù„Ø§Ø­Ù‚Ø§Ù‹."
        )
        return MAIN_MENU
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
    keyboard = []
    for product in products:
        keyboard.append([InlineKeyboardButton(f"{product['name']} - {product['price']} $", callback_data=f"product_{product['id']}")])
    
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="back_to_main")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø´Ø±Ø§Ø¡: ğŸ›\n"
        "Ø§Ø®ØªØ± Ù…Ù†ØªØ¬Ø§Ù‹ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙØ§ØµÙŠÙ„:",
        reply_markup=reply_markup
    )
    
    return BROWSE_PRODUCTS

# Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬
async def product_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == "back_to_main":
        await query.message.delete()
        return MAIN_MENU
    
    product_id = query.data.split("_")[1]
    products = load_products()
    
    product = next((p for p in products if p['id'] == product_id), None)
    
    if not product:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªÙˆÙØ±. ğŸ˜”"
        )
        return BROWSE_PRODUCTS
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØ§ØµÙŠÙ„
    keyboard = [
        [InlineKeyboardButton("ğŸ›’ Ø´Ø±Ø§Ø¡ Ø§Ù„Ø¢Ù†", callback_data=f"buy_{product_id}")],
        [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…Ù†ØªØ¬Ø§Øª", callback_data="back_to_products")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Ø¥Ø±Ø³Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬
    await query.message.edit_text(
        f"ğŸ“¦ *{product['name']}*\n\n"
        f"ğŸ“ *Ø§Ù„ÙˆØµÙ:* {product['description']}\n\n"
        f"ğŸ’° *Ø§Ù„Ø³Ø¹Ø±:* {product['price']} $\n\n"
        f"ğŸ›’ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ 'Ø´Ø±Ø§Ø¡ Ø§Ù„Ø¢Ù†' Ù„Ø·Ù„Ø¨ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†ØªØ¬.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    return PRODUCT_DETAILS

# Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
async def back_to_products(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    products = load_products()
    
    if not products:
        await query.message.edit_text(
            "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹. ğŸ˜”\n"
            "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù„Ø§Ø­Ù‚Ø§Ù‹."
        )
        return MAIN_MENU
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
    keyboard = []
    for product in products:
        keyboard.append([InlineKeyboardButton(f"{product['name']} - {product['price']} $", callback_data=f"product_{product['id']}")])
    
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="back_to_main")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.message.edit_text(
        "Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø´Ø±Ø§Ø¡: ğŸ›\n"
        "Ø§Ø®ØªØ± Ù…Ù†ØªØ¬Ø§Ù‹ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙØ§ØµÙŠÙ„:",
        reply_markup=reply_markup
    )
    
    return BROWSE_PRODUCTS

# Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡
async def start_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    product_id = query.data.split("_")[1]
    products = load_products()
    
    product = next((p for p in products if p['id'] == product_id), None)
    
    if not product:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªÙˆÙØ±. ğŸ˜”"
        )
        return BROWSE_PRODUCTS
    
    # Ø­ÙØ¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    context.user_data['purchase_product_id'] = product_id
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡
    keyboard = [
        [InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡", callback_data="confirm_purchase")],
        [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=f"product_{product_id}")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.message.edit_text(
        f"ğŸ›’ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡*\n\n"
        f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
        f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
        f"Ù„Ù„Ø´Ø±Ø§Ø¡ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ {OWNER_USERNAME} ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±ØµÙŠØ¯.\n"
        f"Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒÙŠØ¯ØŒ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.\n\n"
        f"Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    return CONFIRM_PURCHASE

# ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡
async def confirm_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data != "confirm_purchase":
        return PRODUCT_DETAILS
    
    product_id = context.user_data.get('purchase_product_id')
    if not product_id:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
        )
        return MAIN_MENU
    
    products = load_products()
    product = next((p for p in products if p['id'] == product_id), None)
    
    if not product:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªÙˆÙØ±. ğŸ˜”"
        )
        return BROWSE_PRODUCTS
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
    order = {
        "id": str(int(time.time())),
        "product_id": product_id,
        "product_name": product['name'],
        "product_price": product['price'],
        "user_id": update.effective_user.id,
        "user_name": update.effective_user.first_name,
        "username": update.effective_user.username,
        "status": "pending",
        "created_at": int(time.time())
    }
    
    # Ø­ÙØ¸ Ø§Ù„Ø·Ù„Ø¨
    orders = load_orders()
    orders.append(order)
    save_orders(orders)
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø´Ø±Ù
    try:
        admin_keyboard = [
            [InlineKeyboardButton("âœ… Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù„Ø¨", callback_data=f"approve_{order['id']}")],
            [InlineKeyboardButton("âŒ Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨", callback_data=f"reject_{order['id']}")]
        ]
        
        admin_markup = InlineKeyboardMarkup(admin_keyboard)
        
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=f"ğŸ”” *Ø·Ù„Ø¨ Ø´Ø±Ø§Ø¡ Ø¬Ø¯ÙŠØ¯*\n\n"
                 f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: `{order['id']}`\n"
                 f"ğŸ‘¤ Ø§Ù„Ù…Ø´ØªØ±ÙŠ: {order['user_name']} (@{order['username']})\n"
                 f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
                 f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
                 f"ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ø±ØµÙŠØ¯ Ù‚Ø¨Ù„ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©.",
            reply_markup=admin_markup,
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Error sending notification to admin: {e}")
    
    # Ø¥Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await query.message.edit_text(
        f"âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!*\n\n"
        f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
        f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
        f"ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ {OWNER_USERNAME} Ù„Ø¥ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹.\n"
        f"Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ØŒ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.\n\n"
        f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! ğŸ™",
        parse_mode='Markdown'
    )
    
    # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    if 'purchase_product_id' in context.user_data:
        del context.user_data['purchase_product_id']
    
    return MAIN_MENU

# Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù„Ø¨
async def approve_order(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if not is_admin(query.from_user.id):
        await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    order_id = query.data.split("_")[1]
    orders = load_orders()
    
    order_index = next((i for i, o in enumerate(orders) if o['id'] == order_id), None)
    
    if order_index is None:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ğŸ˜”"
        )
        return ADMIN_MENU
    
    # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨
    orders[order_index]['status'] = "approved"
    orders[order_index]['approved_at'] = int(time.time())
    save_orders(orders)
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬
    products = load_products()
    product = next((p for p in products if p['id'] == orders[order_index]['product_id']), None)
    
    if not product:
        await query.message.edit_text(
            "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù„Ø¨ØŒ Ù„ÙƒÙ† Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªÙˆÙØ±. ğŸ˜”"
        )
        return ADMIN_MENU
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù„Ù…Ø´ØªØ±ÙŠ
    try:
        user_id = orders[order_index]['user_id']
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯ Ø£ÙˆÙ„Ø§Ù‹
        await context.bot.send_message(
            chat_id=user_id,
            text=f"ğŸ‰ *ØªÙ… Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ùƒ!*\n\n"
                 f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
                 f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
                 f"Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ùƒ Ø§Ù„Ø¢Ù†...",
            parse_mode='Markdown'
        )
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ø­Ø³Ø¨ Ù†ÙˆØ¹Ù‡
        if product['file_type'] == "photo":
            await context.bot.send_photo(
                chat_id=user_id,
                photo=product['file_id'],
                caption=f"ğŸ *{product['name']}*\n\n{product['description']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        elif product['file_type'] == "document":
            await context.bot.send_document(
                chat_id=user_id,
                document=product['file_id'],
                caption=f"ğŸ *{product['name']}*\n\n{product['description']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        elif product['file_type'] == "video":
            await context.bot.send_video(
                chat_id=user_id,
                video=product['file_id'],
                caption=f"ğŸ *{product['name']}*\n\n{product['description']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        elif product['file_type'] == "audio":
            await context.bot.send_audio(
                chat_id=user_id,
                audio=product['file_id'],
                caption=f"ğŸ *{product['name']}*\n\n{product['description']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        elif product['file_type'] == "voice":
            await context.bot.send_voice(
                chat_id=user_id,
                voice=product['file_id'],
                caption=f"ğŸ *{product['name']}*\n\n{product['description']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        elif product['file_type'] == "text":
            await context.bot.send_message(
                chat_id=user_id,
                text=f"ğŸ *{product['name']}*\n\n{product['description']}\n\n{product['file_id']}\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ø´Ø±Ø§Ø¦Ùƒ Ù…Ù† Ù…ØªØ¬Ø±Ù†Ø§! {OWNER_USERNAME}",
                parse_mode='Markdown'
            )
        
        # ØªØ­Ø¯ÙŠØ« Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø´Ø±Ù
        await query.message.edit_text(
            f"âœ… *ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù„Ø¨ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬*\n\n"
            f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: `{order_id}`\n"
            f"ğŸ‘¤ Ø§Ù„Ù…Ø´ØªØ±ÙŠ: {orders[order_index]['user_name']} (@{orders[order_index]['username']})\n"
            f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
            f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù„Ù…Ø´ØªØ±ÙŠ Ø¨Ù†Ø¬Ø§Ø­. âœ…",
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error sending product to user: {e}")
        await query.message.edit_text(
            f"âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù†ØªØ¬*\n\n"
            f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: `{order_id}`\n"
            f"ğŸ‘¤ Ø§Ù„Ù…Ø´ØªØ±ÙŠ: {orders[order_index]['user_name']} (@{orders[order_index]['username']})\n"
            f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{product['name']}*\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{product['price']} $*\n\n"
            f"Ø§Ù„Ø®Ø·Ø£: {str(e)}",
            parse_mode='Markdown'
        )
    
    return ADMIN_MENU

# Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨
async def reject_order(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if not is_admin(query.from_user.id):
        await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    order_id = query.data.split("_")[1]
    orders = load_orders()
    
    order_index = next((i for i, o in enumerate(orders) if o['id'] == order_id), None)
    
    if order_index is None:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ğŸ˜”"
        )
        return ADMIN_MENU
    
    # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨
    orders[order_index]['status'] = "rejected"
    orders[order_index]['rejected_at'] = int(time.time())
    save_orders(orders)
    
    # Ø¥Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±ÙŠ
    try:
        user_id = orders[order_index]['user_id']
        
        await context.bot.send_message(
            chat_id=user_id,
            text=f"âŒ *ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨Ùƒ*\n\n"
                 f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{orders[order_index]['product_name']}*\n"
                 f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{orders[order_index]['product_price']} $*\n\n"
                 f"ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ {OWNER_USERNAME} Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª.",
            parse_mode='Markdown'
        )
        
        # ØªØ­Ø¯ÙŠØ« Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø´Ø±Ù
        await query.message.edit_text(
            f"âŒ *ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨*\n\n"
            f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: `{order_id}`\n"
            f"ğŸ‘¤ Ø§Ù„Ù…Ø´ØªØ±ÙŠ: {orders[order_index]['user_name']} (@{orders[order_index]['username']})\n"
            f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{orders[order_index]['product_name']}*\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{orders[order_index]['product_price']} $*\n\n"
            f"ØªÙ… Ø¥Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±ÙŠ Ø¨Ø§Ù„Ø±ÙØ¶.",
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error notifying user about rejection: {e}")
        await query.message.edit_text(
            f"âŒ *ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨ØŒ Ù„ÙƒÙ† Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±ÙŠ*\n\n"
            f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: `{order_id}`\n"
            f"ğŸ‘¤ Ø§Ù„Ù…Ø´ØªØ±ÙŠ: {orders[order_index]['user_name']} (@{orders[order_index]['username']})\n"
            f"ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: *{orders[order_index]['product_name']}*\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *{orders[order_index]['product_price']} $*\n\n"
            f"Ø§Ù„Ø®Ø·Ø£: {str(e)}",
            parse_mode='Markdown'
        )
    
    return ADMIN_MENU

# Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
async def view_orders(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    
    if not is_admin(user.id):
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    orders = load_orders()
    
    if not orders:
        await update.message.reply_text(
            "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹. ğŸ“­"
        )
        return ADMIN_MENU
    
    # ÙÙ„ØªØ±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©
    pending_orders = [o for o in orders if o['status'] == 'pending']
    approved_orders = [o for o in orders if o['status'] == 'approved']
    rejected_orders = [o for o in orders if o['status'] == 'rejected']
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù†Øµ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
    text = "*ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª*\n\n"
    
    if pending_orders:
        text += "*ğŸ•’ Ø·Ù„Ø¨Ø§Øª Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±:*\n"
        for order in pending_orders:
            text += f"- {order['product_name']} ({order['product_price']} $) - @{order['username']}\n"
        text += "\n"
    
    if approved_orders:
        text += "*âœ… Ø·Ù„Ø¨Ø§Øª ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„ÙŠÙ‡Ø§:*\n"
        for order in approved_orders:
            text += f"- {order['product_name']} ({order['product_price']} $) - @{order['username']}\n"
        text += "\n"
    
    if rejected_orders:
        text += "*âŒ Ø·Ù„Ø¨Ø§Øª Ù…Ø±ÙÙˆØ¶Ø©:*\n"
        for order in rejected_orders:
            text += f"- {order['product_name']} ({order['product_price']} $) - @{order['username']}\n"
    
    await update.message.reply_text(
        text,
        parse_mode='Markdown'
    )
    
    return ADMIN_MENU

# Ø­Ø°Ù Ù…Ù†ØªØ¬
async def delete_product_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    
    if not is_admin(user.id):
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
        return MAIN_MENU
    
    products = load_products()
    
    if not products:
        await update.message.reply_text(
            "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª Ù„Ø­Ø°ÙÙ‡Ø§. ğŸ“­"
        )
        return ADMIN_MENU
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù„Ù„Ø­Ø°Ù
    keyboard = []
    for product in products:
        keyboard.append([InlineKeyboardButton(f"{product['name']} - {product['price']} $", callback_data=f"delete_{product['id']}")])
    
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="back_to_admin")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø°ÙÙ‡:",
        reply_markup=reply_markup
    )
    
    return ADMIN_MENU

# ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬
async def delete_product_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == "back_to_admin":
        await query.message.delete()
        return ADMIN_MENU
    
    product_id = query.data.split("_")[1]
    products = load_products()
    
    product = next((p for p in products if p['id'] == product_id), None)
    
    if not product:
        await query.message.edit_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ğŸ˜”"
        )
        return ADMIN_MENU
    
    # Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬
    products = [p for p in products if p['id'] != product_id]
    save_products(products)
    
    await query.message.edit_text(
        f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬ *{product['name']}* Ø¨Ù†Ø¬Ø§Ø­."
    )
    
    return ADMIN_MENU

# Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ
async def contact_owner(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        f"Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ù…Ø§Ù„Ùƒ Ø§Ù„Ù…ØªØ¬Ø±ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n\n"
        f"ğŸ‘¤ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø§Ù„Ùƒ: {OWNER_USERNAME}\n"
        f"ğŸ“¢ Ù‚Ù†Ø§Ø© Ø§Ù„Ù…ØªØ¬Ø±: {OWNER_CHANNEL}\n\n"
        f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ù‡ØªÙ…Ø§Ù…Ùƒ! ğŸ™"
    )
    
    return MAIN_MENU

# Ø­ÙˆÙ„ Ø§Ù„Ù…ØªØ¬Ø±
async def about_store(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        f"ğŸª *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…ØªØ¬Ø± {OWNER_USERNAME} Ø§Ù„Ø±Ù‚Ù…ÙŠ*\n\n"
        f"Ù…ØªØ¬Ø±Ù†Ø§ Ù…ØªØ®ØµØµ ÙÙŠ Ø¨ÙŠØ¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ø¨Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹Ù‡Ø§:\n"
        f"ğŸ“± ØªØ·Ø¨ÙŠÙ‚Ø§Øª\n"
        f"ğŸ“‚ Ù…Ù„ÙØ§Øª\n"
        f"ğŸ–¼ ØµÙˆØ±\n"
        f"ğŸ¬ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª\n"
        f"ğŸ“ Ù†ØµÙˆØµ\n"
        f"ÙˆØºÙŠØ±Ù‡Ø§ Ø§Ù„ÙƒØ«ÙŠØ±!\n\n"
        f"ğŸ‘¤ Ø§Ù„Ù…Ø§Ù„Ùƒ: {OWNER_USERNAME}\n"
        f"ğŸ“¢ Ù‚Ù†Ø§Ø© Ø§Ù„Ù…ØªØ¬Ø±: {OWNER_CHANNEL}\n\n"
        f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ø²ÙŠØ§Ø±ØªÙƒ! ğŸ™",
        parse_mode='Markdown'
    )
    
    return MAIN_MENU

# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text
    
    if text == "ğŸ› ØªØµÙØ­ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª":
        return await browse_products(update, context)
    elif text == "ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ":
        return await contact_owner(update, context)
    elif text == "/start":
        return await about_store(update, context)
    elif text == "ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù":
        return await admin_panel(update, context)
    elif text == "â• Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯":
        return await add_product_start(update, context)
    elif text == "ğŸ“Š Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª":
        return await view_orders(update, context)
    elif text == "ğŸ—‘ Ø­Ø°Ù Ù…Ù†ØªØ¬":
        return await delete_product_start(update, context)
    elif text == "ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        return await start(update, context)
    else:
        await update.message.reply_text(
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªÙ†Ù‚Ù„ ÙÙŠ Ø§Ù„Ù…ØªØ¬Ø±."
        )
        return MAIN_MENU

# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    
    if query.data.startswith("product_"):
        return await product_details(update, context)
    elif query.data == "back_to_products":
        return await back_to_products(update, context)
    elif query.data.startswith("buy_"):
        return await start_purchase(update, context)
    elif query.data == "confirm_purchase":
        return await confirm_purchase(update, context)
    elif query.data.startswith("approve_"):
        return await approve_order(update, context)
    elif query.data.startswith("reject_"):
        return await reject_order(update, context)
    elif query.data.startswith("delete_"):
        return await delete_product_confirm(update, context)
    elif query.data == "back_to_admin":
        return await admin_panel(update, context)
    elif query.data == "back_to_main":
        await query.message.delete()
        return MAIN_MENU
    else:
        await query.answer("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ù…Ø§.")
        return MAIN_MENU

def main() -> None:
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª."""
    # Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    ensure_data_files()
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    application = Application.builder().token(TOKEN).build()
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø©
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            MAIN_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message),
                CallbackQueryHandler(handle_callback)
            ],
            ADMIN_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message),
                CallbackQueryHandler(handle_callback)
            ],
            ADD_PRODUCT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, add_product_start)
            ],
            PRODUCT_NAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_product_name)
            ],
            PRODUCT_DESCRIPTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_product_description)
            ],
            PRODUCT_PRICE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_product_price)
            ],
            PRODUCT_FILE: [
                MessageHandler(filters.PHOTO, receive_product_file),
                MessageHandler(filters.Document.ALL, receive_product_file),
                MessageHandler(filters.VIDEO, receive_product_file),
                MessageHandler(filters.AUDIO, receive_product_file),
                MessageHandler(filters.VOICE, receive_product_file),
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_product_file)
            ],
            BROWSE_PRODUCTS: [
                CallbackQueryHandler(handle_callback)
            ],
            PRODUCT_DETAILS: [
                CallbackQueryHandler(handle_callback)
            ],
            CONFIRM_PURCHASE: [
                CallbackQueryHandler(handle_callback)
            ],
            ADMIN_APPROVE: [
                CallbackQueryHandler(handle_callback)
            ],
            WAITING_PAYMENT: [
                CallbackQueryHandler(handle_callback)
            ]
        },
        fallbacks=[CommandHandler("start", start)],
    )
    
    application.add_handler(conv_handler)
    
    # Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª
    application.run_polling()

if __name__ == '__main__':
    main()
